<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fase 3: Formas Geom√©tricas e Padr√µes</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Comic Sans MS', cursive, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .game-container {
      background: white;
      border-radius: 30px;
      padding: 40px;
      max-width: 900px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    h1 {
      text-align: center;
      color: #667eea;
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    }

    .subtitle {
      text-align: center;
      color: #764ba2;
      font-size: 1.2rem;
      margin-bottom: 30px;
    }

    .score-board {
      display: flex;
      justify-content: space-around;
      margin-bottom: 30px;
      padding: 20px;
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      border-radius: 20px;
      color: white;
    }

    .score-item {
      text-align: center;
    }

    .score-label {
      font-size: 0.9rem;
      opacity: 0.9;
    }

    .score-value {
      font-size: 2rem;
      font-weight: bold;
      margin-top: 5px;
    }

    .game-area {
      background: #f8f9fa;
      border-radius: 20px;
      padding: 30px;
      min-height: 400px;
      margin-bottom: 20px;
    }

    .instruction {
      text-align: center;
      font-size: 1.5rem;
      color: #333;
      margin-bottom: 30px;
      font-weight: bold;
    }

    /* Ca√ßa √†s Formas */
    .shapes-hunt {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .shape-item {
      width: 100px;
      height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.3s ease, opacity 0.3s ease;
      margin: 0 auto;
    }

    .shape-item:hover {
      transform: scale(1.1);
    }

    .shape-item.found {
      opacity: 0.3;
      pointer-events: none;
      transform: scale(0.8);
    }

    .shape-item.wrong {
      animation: shake 0.5s;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

    /* Formas SVG */
    .circle {
      width: 80px;
      height: 80px;
      border-radius: 50%;
    }

    .square {
      width: 80px;
      height: 80px;
    }

    .triangle {
      width: 0;
      height: 0;
      border-left: 40px solid transparent;
      border-right: 40px solid transparent;
      border-bottom: 80px solid;
    }

    .rectangle {
      width: 100px;
      height: 60px;
    }

    /* Padr√µes */
    .pattern-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      margin: 30px 0;
      flex-wrap: wrap;
    }

    .pattern-item {
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      border: 3px dashed #ccc;
      border-radius: 15px;
    }

    .pattern-item.filled {
      border: 3px solid #667eea;
    }

    .pattern-item.question {
      background: #fffacd;
      border: 3px solid #ffd700;
      font-size: 3rem;
      color: #ffd700;
    }

    .options-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 30px;
      flex-wrap: wrap;
    }

    .option-item {
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      border: 3px solid #667eea;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .option-item:hover {
      transform: scale(1.1);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .option-item.correct {
      animation: pulse 0.5s;
      border-color: #4caf50;
      background: #c8e6c9;
    }

    .option-item.incorrect {
      animation: shake 0.5s;
      border-color: #f44336;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    /* Bot√µes */
    .button-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }

    .btn {
      padding: 15px 40px;
      font-size: 1.2rem;
      font-weight: bold;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
    }

    .btn-success {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      color: white;
    }

    .btn-success:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 20px rgba(76, 175, 80, 0.4);
    }

    /* Modal de Vit√≥ria */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 40px;
      border-radius: 30px;
      text-align: center;
      max-width: 500px;
      animation: modalAppear 0.5s ease;
    }

    @keyframes modalAppear {
      from {
        transform: scale(0.5);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .modal-content h2 {
      color: #667eea;
      font-size: 2.5rem;
      margin-bottom: 20px;
    }

    .modal-content p {
      font-size: 1.3rem;
      color: #333;
      margin-bottom: 30px;
    }

    .stars {
      font-size: 3rem;
      margin: 20px 0;
    }

    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>üé® Formas Geom√©tricas e Padr√µes</h1>
    <p class="subtitle">Fase 3 - Jogo Educativo de Matem√°tica</p>

    <div class="score-board">
      <div class="score-item">
        <div class="score-label">Pontos</div>
        <div class="score-value" id="score">0</div>
      </div>
      <div class="score-item">
        <div class="score-label">N√≠vel</div>
        <div class="score-value" id="level">1</div>
      </div>
      <div class="score-item">
        <div class="score-label">Acertos</div>
        <div class="score-value" id="correct">0</div>
      </div>
    </div>

    <div class="game-area" id="gameArea">
      <!-- Conte√∫do din√¢mico do jogo -->
    </div>

    <div class="button-container">
      <button class="btn btn-primary" id="nextBtn" style="display: none;">Pr√≥ximo Desafio</button>
    </div>
  </div>

  <!-- Modal de Vit√≥ria -->
  <div class="modal" id="winModal">
    <div class="modal-content">
      <h2>üéâ Parab√©ns!</h2>
      <div class="stars">‚≠ê‚≠ê‚≠ê</div>
      <p id="winMessage">Voc√™ completou todos os desafios!</p>
      <button class="btn btn-success" onclick="location.reload()">Jogar Novamente</button>
    </div>
  </div>

  <script>
    // Estado do jogo
    const gameState = {
      score: 0,
      level: 1,
      correct: 0,
      currentChallenge: 0,
      challenges: []
    };

    // Cores dispon√≠veis
    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];

    // Tipos de desafios
    const challengeTypes = [
      'shapeHunt',    // Ca√ßa √†s formas
      'pattern',      // Completar padr√£o
      'shapeHunt',    // Ca√ßa √†s formas (repetido)
      'pattern',      // Completar padr√£o (repetido)
      'shapeHunt'     // Ca√ßa √†s formas final
    ];

    // Formas dispon√≠veis
    const shapes = ['circle', 'square', 'triangle', 'rectangle'];
    const shapeNames = {
      'circle': 'c√≠rculos',
      'square': 'quadrados',
      'triangle': 'tri√¢ngulos',
      'rectangle': 'ret√¢ngulos'
    };

    // Inicializar jogo
    function initGame() {
      generateChallenges();
      loadChallenge();
    }

    // Gerar desafios
    function generateChallenges() {
      gameState.challenges = challengeTypes.map(type => {
        if (type === 'shapeHunt') {
          return generateShapeHuntChallenge();
        } else {
          return generatePatternChallenge();
        }
      });
    }

    // Gerar desafio de ca√ßa √†s formas
    function generateShapeHuntChallenge() {
      const targetShape = shapes[Math.floor(Math.random() * shapes.length)];
      const targetCount = Math.floor(Math.random() * 3) + 3; // 3-5 formas alvo
      const totalShapes = 12;
      
      const shapesList = [];
      
      // Adicionar formas alvo
      for (let i = 0; i < targetCount; i++) {
        shapesList.push({
          shape: targetShape,
          color: colors[Math.floor(Math.random() * colors.length)],
          isTarget: true
        });
      }
      
      // Adicionar formas distratoras
      while (shapesList.length < totalShapes) {
        const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
        if (randomShape !== targetShape) {
          shapesList.push({
            shape: randomShape,
            color: colors[Math.floor(Math.random() * colors.length)],
            isTarget: false
          });
        }
      }
      
      // Embaralhar
      shapesList.sort(() => Math.random() - 0.5);
      
      return {
        type: 'shapeHunt',
        targetShape: targetShape,
        targetCount: targetCount,
        shapes: shapesList,
        found: 0
      };
    }

    // Gerar desafio de padr√£o
    function generatePatternChallenge() {
      const patternLength = 5;
      const pattern = [];
      
      // Criar padr√£o simples (AB, ABC, ou AABB)
      const patternTypes = [
        ['circle', 'square'],
        ['circle', 'square', 'triangle'],
        ['circle', 'circle', 'square', 'square']
      ];
      
      const selectedPattern = patternTypes[Math.floor(Math.random() * patternTypes.length)];
      
      for (let i = 0; i < patternLength; i++) {
        const shape = selectedPattern[i % selectedPattern.length];
        pattern.push({
          shape: shape,
          color: colors[i % colors.length]
        });
      }
      
      // Escolher posi√ß√£o para a pergunta
      const questionIndex = patternLength - 1;
      const correctAnswer = pattern[questionIndex];
      
      // Gerar op√ß√µes
      const options = [correctAnswer];
      while (options.length < 3) {
        const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
        if (!options.some(opt => opt.shape === randomShape)) {
          options.push({
            shape: randomShape,
            color: colors[Math.floor(Math.random() * colors.length)]
          });
        }
      }
      options.sort(() => Math.random() - 0.5);
      
      return {
        type: 'pattern',
        pattern: pattern,
        questionIndex: questionIndex,
        correctAnswer: correctAnswer,
        options: options
      };
    }

    // Carregar desafio
    function loadChallenge() {
      const challenge = gameState.challenges[gameState.currentChallenge];
      const gameArea = document.getElementById('gameArea');
      
      if (challenge.type === 'shapeHunt') {
        renderShapeHunt(challenge);
      } else {
        renderPattern(challenge);
      }
      
      document.getElementById('nextBtn').style.display = 'none';
    }

    // Renderizar ca√ßa √†s formas
    function renderShapeHunt(challenge) {
      const gameArea = document.getElementById('gameArea');
      gameArea.innerHTML = `
        <div class="instruction">
          Encontre todos os ${shapeNames[challenge.targetShape]}! 
          <span style="color: #667eea;">(${challenge.found}/${challenge.targetCount})</span>
        </div>
        <div class="shapes-hunt" id="shapesContainer"></div>
      `;
      
      const container = document.getElementById('shapesContainer');
      
      challenge.shapes.forEach((item, index) => {
        const shapeDiv = document.createElement('div');
        shapeDiv.className = 'shape-item';
        shapeDiv.innerHTML = createShape(item.shape, item.color);
        shapeDiv.onclick = () => handleShapeClick(index, item.isTarget, challenge);
        container.appendChild(shapeDiv);
      });
    }

    // Criar forma SVG
    function createShape(shape, color) {
      if (shape === 'circle') {
        return `<div class="circle" style="background-color: ${color};"></div>`;
      } else if (shape === 'square') {
        return `<div class="square" style="background-color: ${color};"></div>`;
      } else if (shape === 'triangle') {
        return `<div class="triangle" style="border-bottom-color: ${color};"></div>`;
      } else if (shape === 'rectangle') {
        return `<div class="rectangle" style="background-color: ${color};"></div>`;
      }
    }

    // Lidar com clique na forma
    function handleShapeClick(index, isTarget, challenge) {
      const shapeItems = document.querySelectorAll('.shape-item');
      const clickedItem = shapeItems[index];
      
      if (isTarget) {
        clickedItem.classList.add('found');
        challenge.found++;
        challenge.shapes[index].isTarget = false; // Marcar como encontrado
        
        gameState.score += 10;
        gameState.correct++;
        updateScore();
        
        // Atualizar contador
        document.querySelector('.instruction').innerHTML = `
          Encontre todos os ${shapeNames[challenge.targetShape]}! 
          <span style="color: #667eea;">(${challenge.found}/${challenge.targetCount})</span>
        `;
        
        if (challenge.found === challenge.targetCount) {
          setTimeout(() => {
            showSuccess();
          }, 500);
        }
      } else {
        clickedItem.classList.add('wrong');
        setTimeout(() => {
          clickedItem.classList.remove('wrong');
        }, 500);
      }
    }

    // Renderizar padr√£o
    function renderPattern(challenge) {
      const gameArea = document.getElementById('gameArea');
      gameArea.innerHTML = `
        <div class="instruction">Complete o padr√£o!</div>
        <div class="pattern-container" id="patternContainer"></div>
        <div class="options-container" id="optionsContainer"></div>
      `;
      
      const patternContainer = document.getElementById('patternContainer');
      
      challenge.pattern.forEach((item, index) => {
        const patternDiv = document.createElement('div');
        if (index === challenge.questionIndex) {
          patternDiv.className = 'pattern-item question';
          patternDiv.innerHTML = '?';
        } else {
          patternDiv.className = 'pattern-item filled';
          patternDiv.innerHTML = createShape(item.shape, item.color);
        }
        patternContainer.appendChild(patternDiv);
      });
      
      const optionsContainer = document.getElementById('optionsContainer');
      
      challenge.options.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'option-item';
        optionDiv.innerHTML = createShape(option.shape, option.color);
        optionDiv.onclick = () => handlePatternClick(option, challenge, optionDiv);
        optionsContainer.appendChild(optionDiv);
      });
    }

    // Lidar com clique no padr√£o
    function handlePatternClick(selectedOption, challenge, optionDiv) {
      const isCorrect = selectedOption.shape === challenge.correctAnswer.shape;
      
      if (isCorrect) {
        optionDiv.classList.add('correct');
        gameState.score += 20;
        gameState.correct++;
        updateScore();
        
        // Mostrar resposta correta no padr√£o
        const questionItem = document.querySelector('.pattern-item.question');
        questionItem.className = 'pattern-item filled';
        questionItem.innerHTML = createShape(challenge.correctAnswer.shape, challenge.correctAnswer.color);
        
        setTimeout(() => {
          showSuccess();
        }, 1000);
      } else {
        optionDiv.classList.add('incorrect');
        setTimeout(() => {
          optionDiv.classList.remove('incorrect');
        }, 500);
      }
    }

    // Mostrar sucesso
    function showSuccess() {
      document.getElementById('nextBtn').style.display = 'block';
    }

    // Pr√≥ximo desafio
    document.getElementById('nextBtn').addEventListener('click', () => {
      gameState.currentChallenge++;
      
      if (gameState.currentChallenge >= gameState.challenges.length) {
        showWinModal();
      } else {
        gameState.level++;
        updateScore();
        loadChallenge();
      }
    });

    // Atualizar placar
    function updateScore() {
      document.getElementById('score').textContent = gameState.score;
      document.getElementById('level').textContent = gameState.level;
      document.getElementById('correct').textContent = gameState.correct;
    }

    // Mostrar modal de vit√≥ria
    function showWinModal() {
      const modal = document.getElementById('winModal');
      const message = document.getElementById('winMessage');
      message.textContent = `Voc√™ completou todos os desafios com ${gameState.score} pontos!`;
      modal.classList.add('active');
    }

    // Iniciar jogo ao carregar
    window.onload = initGame;
  </script>
</body>
</html>

